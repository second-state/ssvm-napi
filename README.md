# Second State WebAssembly VM for Node.js Addon

The [Second State VM (SSVM)](https://github.com/second-state/ssvm) is a high-performance WebAssembly runtime optimized for server-side applications. This project provides support for accessing SSVM as a Node.js addon. It allows Node.js applications to call WebAssembly functions written in Rust or other high-performance languages. [Why do you want to run WebAssembly on the server-side?](https://cloud.secondstate.io/server-side-webassembly/why) The SSVM addon could interact with the wasm files generated by the [ssvmup](https://github.com/second-state/ssvmup) compiler tool.

## NOTICE

SSVM Node.js Addon is in active development.

In the current stage, our prebuilt version **only supports** x86\_64 Linux.
Or you could use `--build-from-source` flag to build from source during addon installation.

## Requirements

After SSVM Napi 0.4.0 release, we support ahead-of-time compilation mode.
Users should install the dependencies by the following requirments:

* boost >= 1.65.0
* llvm >= 10
* lld >= 10
* GLIBCXX >= 3.4.28
* g++ version >= 9.0 (Optional, if you have to build from source)

### For ubuntu

```bash
# Setup
sudo apt update
sudo apt -y upgrade
sudo apt install -y software-properties-common wget

# Install boost
sudo apt install -y libboost-all-dev

# Install LLVM and LLD
wget -O - https://apt.llvm.org/llvm-snapshot.gpg.key|apt-key add -
sudo apt install -y libllvm10 llvm-10 llvm-10-dev \
	liblld-10-dev llvm-10-runtime libclang-common-10-dev

# Update libc++ to the latest version
sudo add-apt-repository ppa:ubuntu-toolchain-r/test
sudo apt update
sudo apt -y upgrade

# (Optional) Install g++-9
sudo apt install -y g++-9
```

## Support Targets

SSVM Node.js Addon supports three different targets including:
1. **Rust Wasm-Bindgen**
2. **General wasm32-wasi backend (Interpreter mode)**.
3. **General wasm32-wasi backend (Ahead-of-Time mode)**.

We will show the usage of all targets in the following sections.


### Target: Rust Wasm-Bindgen

Please refer to [Tutorial: A Wasm-Bindgen application](./Tutorial_Wasm_Bindgen.md).

### Target: General Wasm32-wasi target (Interpreter mode)

Please refer to [Tutorial: A General Wasm32-wasi application](./Tutorial_General_Wasi.md).

### Target: General Wasm32-wasi target (Ahead-of-Time mode)

Please refer to [Tutorial: A General Wasm32-wasi application AOT mode](./Tutorial_General_Wasi_AOT.md).

## APIs

### Constructor: `ssvm.VM(wasm, wasi_options) -> vm_instance`
* Create a ssvm instance by given wasm file and wasi options.
* Arguments:
	* `wasm`: Input wasm file, can be the following three formats:
		1. Wasm file path (String, e.g. `/tmp/hello.wasm`)
		2. Wasm bytecode format which is the content of a wasm binary file (Uint8Array)
		3. Native bytecode format which is generated by our AOT compiler (Uint8Array)
	* `wasi_options`: A wasi options object for setup the execution environment.
		* `wasi_options` <JS Object>
			* `args` <JS Array>: An array of strings that Wasm application will get as function arguments. Default: `[]`
			* `env` <JS Object>: An object like `process.env` that Wasm application will get as its environment variables. Default: `{}`
			* `DisableWasmBindgen` <Boolean>: To avoid ambigous entry point between `Wasm-Bindgen mode` and `General Wasm32-wasi mode`. Dafault: `true`.
* Return value:
	* `vm_instance`: A ssvm instance.

### Methods (Wasm-Bindgen related)

#### `RunInt(function_name, args...) -> Integer`
* Emit `function_name` with `args` and expect the return value type is `Integer`.
* Arguments:
	* `function_name` <String>: The function name which users want to emit.
	* `args` <Integer/String/Uint8Array>\*: The function arguments. The delimiter is `,`
* Example:
```javascript
let result = RunInt("Add", 1, 2);
// result should be 3
```

#### `RunString(function_name, args...) -> String`
* Emit `function_name` with `args` and expect the return value type is `String`.
* Arguments:
	* `function_name` <String>: The function name which users want to emit.
	* `args` <Integer/String/Uint8Array>\*: The function arguments. The delimiter is `,`
* Example:
```javascript
let result = RunString("PrintMathScore", "Amy", 98);
// result: "Amyâ€™s math score is 98".
```


#### `RunUint8Array(function_name, args...) -> Uint8Array`
* Emit `function_name` with `args` and expect the return value type is `Uint8Array`.
* Arguments:
	* `function_name` <String>: The function name which users want to emit.
	* `args` <Integer/String/Uint8Array>\*: The function arguments. The delimiter is `,`
* Example:
```javascript
let result = RunUint8Array("Hash", "Hello, world!");
// result: "[12, 22, 33, 42, 51]".
```

### Methods (General Wasm32-wasi interpreter mode related)

#### `Run("_start"/*entry function name*/, args...) -> Integer`
* Emit a wasi program with `args`. This method only works when the `DisableWasmBindgen` is set to `true`.
* Arguments:
	* `args` <Integer/String/Uint8Array>\*: The function arguments. The delimiter is `,`
* Example:
```javascript
let error_code = Run("RSA_Generate_key_pair", 2048);
// error_code: 0 (0 if success, otherwise, non-zero value).
```


### Methods (General Wasm32-wasi ahead-of-time mode related)

#### `RunAot(wasi_options)`
* Use AoT mode to compile and run wasm application with given wasi options.
* When users emit `RunAot` the first time, it will call `Compile` to compile wasm file into a native bytecode and save this native bytecode to code cache.
* If users run `RunAot` multiple times, it will execute the compiled version from the code cache for speedup.
* Arguments:
	* `wasi_options`: Refer to the Constructor section for more details.

#### `Compile()`
* Compile wasm file into native binary.

#### `GetAotBinary() -> Uint8Array`
* Return the compiled native binary.
